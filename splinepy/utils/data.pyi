import numpy as _np
from _typeshed import Incomplete
from gustaf.helpers.data import DataHolder as _DataHolder

from splinepy._base import SplinepyBase as _SplinepyBase

__all__ = [
    "PhysicalSpaceArray",
    "_DataHolder",
    "enforce_contiguous_values",
    "cartesian_product",
    "SplineDataAdaptor",
    "SplineData",
]

class PhysicalSpaceArray(_np.ndarray):
    def __array_finalize__(self, obj) -> None: ...
    def copy(self, *args, **kwargs): ...
    def view(self, *args, **kwargs): ...
    def __iadd__(self, *args, **kwargs): ...
    def __isub__(self, *args, **kwargs): ...
    def __imul__(self, *args, **kwargs): ...
    def __idiv__(self, *args, **kwargs): ...
    def __itruediv__(self, *args, **kwargs): ...
    def __imatmul__(self, *args, **kwargs): ...
    def __ipow__(self, *args, **kwargs): ...
    def __imod__(self, *args, **kwargs): ...
    def __ifloordiv__(self, *args, **kwargs): ...
    def __ilshift__(self, *args, **kwargs): ...
    def __irshift__(self, *args, **kwargs): ...
    def __iand__(self, *args, **kwargs): ...
    def __ixor__(self, *args, **kwargs): ...
    def __ior__(self, *args, **kwargs): ...
    def __array_wrap__(self, *args, **kwargs): ...
    def __setitem__(self, key, value) -> None: ...
    def row_indices(self): ...
    def full_row_indices(self): ...

def enforce_contiguous_values(dict_): ...
def cartesian_product(arrays, reverse: bool = True): ...

class SplineDataAdaptor(_SplinepyBase):
    data: Incomplete
    is_spline: bool
    has_function: bool
    has_locations: bool
    has_evaluate: bool
    arrow_data_only: bool
    parametric_bounds: Incomplete
    function: Incomplete
    locations: Incomplete
    def __init__(
        self,
        data,
        locations: Incomplete | None = None,
        function: Incomplete | None = None,
        parametric_bounds: Incomplete | None = None,
    ) -> None: ...
    def as_vertex_data(
        self,
        resolutions: Incomplete | None = None,
        on: Incomplete | None = None,
    ): ...

class SplineData(_DataHolder):
    def __init__(self, helpee) -> None: ...
    def __setitem__(self, key, value) -> None: ...
    def __getitem__(self, key): ...
    def as_scalar(
        self, key, resolutions, default: Incomplete | None = None
    ): ...
    def as_arrow(
        self,
        key,
        resolutions: Incomplete | None = None,
        on: Incomplete | None = None,
        default: Incomplete | None = None,
    ): ...

class MultipatchData(SplineData):
    def __init__(self, helpee) -> None: ...
    def __setitem__(self, key, value) -> None: ...
    def __getitem__(self, key): ...
    def as_scalar(
        self, key, resolutions, default: Incomplete | None = None
    ): ...
    def as_arrow(
        self,
        key,
        resolutions: Incomplete | None = None,
        on: Incomplete | None = None,
        default: Incomplete | None = None,
    ): ...
