from _typeshed import Incomplete
from splinepy import splinepy_core as _core
from splinepy._base import SplinepyBase as _SplinepyBase
from splinepy.helpme import visualize as _visualize

class RequiredProperties(_SplinepyBase):
    @classmethod
    def __call__(cls, spline): ...
    @classmethod
    def __getitem__(cls, spline_type): ...
    @classmethod
    def of(cls, spline): ...
    @classmethod
    def union(cls, *splines): ...
    @classmethod
    def intersection(cls, *splines): ...

class Spline(_SplinepyBase, _core.PySpline):
    __show_option__ = _visualize.SplineShowOption
    def __init__(self, spline: Incomplete | None = None, **kwargs) -> None: ...
    @property
    def required_properties(self): ...
    @property
    def para_dim(self): ...
    @property
    def dim(self): ...
    @property
    def whatami(self): ...
    @property
    def name(self): ...
    @property
    def has_knot_vectors(self): ...
    @property
    def is_rational(self): ...
    @property
    def extract(self): ...
    @property
    def check(self): ...
    @property
    def integrate(self): ...
    @property
    def create(self): ...
    @property
    def show_options(self): ...
    @property
    def spline_data(self): ...
    def clear(self) -> None: ...
    @property
    def degrees(self): ...
    @degrees.setter
    def degrees(self, degrees) -> None: ...
    @property
    def knot_vectors(self): ...
    @knot_vectors.setter
    def knot_vectors(self, knot_vectors) -> None: ...
    @property
    def unique_knots(self): ...
    @property
    def knot_multiplicities(self): ...
    @property
    def parametric_bounds(self): ...
    @property
    def control_points(self): ...
    @control_points.setter
    def control_points(self, control_points) -> None: ...
    @property
    def control_point_bounds(self): ...
    @property
    def control_mesh_resolutions(self): ...
    def mapper(self, reference): ...
    def greville_abscissae(self, duplicate_tolerance: Incomplete | None = None): ...
    @property
    def multi_index(self): ...
    @property
    def weights(self): ...
    @weights.setter
    def weights(self, weights) -> None: ...
    def evaluate(self, queries, nthreads: Incomplete | None = None): ...
    def sample(self, resolutions, nthreads: Incomplete | None = None): ...
    def derivative(self, queries, orders, nthreads: Incomplete | None = None): ...
    def jacobian(self, queries, nthreads: Incomplete | None = None): ...
    def support(self, queries, nthreads: Incomplete | None = None): ...
    def basis(self, queries, nthreads: Incomplete | None = None): ...
    def basis_and_support(self, queries, nthreads: Incomplete | None = None): ...
    def basis_derivative(self, queries, orders, nthreads: Incomplete | None = None): ...
    def basis_derivative_and_support(self, queries, orders, nthreads: Incomplete | None = None): ...
    def proximities(self, queries, initial_guess_sample_resolutions: Incomplete | None = None, tolerance: Incomplete | None = None, max_iterations: int = -1, aggressive_search_bounds: bool = False, nthreads: Incomplete | None = None, return_verbose: bool = False): ...
    def elevate_degrees(self, parametric_dimensions) -> None: ...
    def reduce_degrees(self, parametric_dimensions, tolerance: Incomplete | None = None): ...
    def export(self, fname) -> None: ...
    def todict(self, tolist: bool = False): ...
    def copy(self, saved_data: bool = True): ...
    def show(self, **kwargs): ...
    def showable(self, **kwargs): ...
    ds = degrees
    kvs = knot_vectors
    cps = control_points
    ws = weights
